*****   Notes   *****

***Stuff to maintain project:***

To generate documentation:
cabal configure
cabal haddock --hyperlink-source

git status
git add
git commit -m
git push

dot -Tpdf GraphDrawingOutput.gv -o GraphDrawingOutput.pdf

*****   Todo   *****
 
*** Automata ***

> Make versions of translations with reachability.

n2d = n2dNaive
n2d = n2dReachable

This is proving a bit hard to make work... Or rather opaque.

> A possible (experimental) reformulation: Automata are things which can be *queried*.
What is the initial state, is this a final state, what is the transition on this etc.What I have now, where these items are explicitly stored, is just one implementation of that. More generally, those things could be ready to be computed but not actually computed. i.e. lazy. Algorithms which work on automata, use them to search a state space (including translations between automata themselves). Translated automata then just do compositions of these queries. Of course, they could be 'realised' into actual state...

Something like this:

class (FAquery q a r) m where

	alpha :: 	  		a -> m -> Bool
	state :: 			q -> m -> Bool
	init :: 				 m -> q
	transition ::  q -> a -> m -> r
	final :: 			q -> m -> Bool

a2n :: ((FAquery q a (BasicPropLogic q) m), (FAquery q a (S.Set q) n)) => m -> n
a2n afa =
	blah blah blah

> I'm starting to think there's no point in having "DFAs" at all, since there is no guarantee in practical programming of having the transition function be a total function anyways.

*** Graph Algorithms ***
NFA emptiness

*** LDL to AFA ***
Write the translation:
 did some NNF stuff... almost ready to put in the transition function of the AFA...
I wonder, perhaps the AFA -> NFA -> DFA all work properly? It all hinges on 'reach'.
I need to actually test these things. Well, I tested NFA -> DFA with reach, which works well.


*** Graph Drawing ***

Make 'pass forward my name' rather than 'request backward for my name' --> DONE

*** Logic & Dependents ***

Change Prog to Reg --> DONE