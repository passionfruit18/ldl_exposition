*****   Notes   *****

***Stuff to maintain project:***

To generate documentation:
cabal configure
cabal haddock --hyperlink-source

git status
git add
git commit -m
git push

dot -Tpdf GraphDrawingOutput.gv -o GraphDrawingOutput.pdf

*****   Todo   *****
 
*** Automata ***

> Make versions of translations with reachability.

d2n = d2nNaive
d2n = d2nReachable

> A more general view: Automata are things which can be *queried*.
What is the initial state, is this a final state, what is the transition on this etc.What I have now, where these items are explicitly stored, is just one implementation of that. More generally, those things could be ready to be computed but not actually computed. i.e. lazy. Algorithms which work on automata, use them to search a state space (including translations between automata themselves). Translated automata then just do compositions of these queries. Of course, they could be 'realised' into actual state...

Something like this:

class (FAquery q a r) m where

	alpha :: 	  		a -> m -> Bool
	state :: 			q -> m -> Bool
	init :: 				 m -> q
	transition ::  q -> a -> m -> r
	final :: 			q -> m -> Bool

a2n :: ((FAquery q a (BasicPropLogic q) m), (FAquery q a (S.Set q) n)) => m -> n
a2n afa =
	blah blah blah


*** Graph Drawing ***

Make 'pass forward my name' rather than 'request backward for my name'

*** Logic & Dependents ***

Change Prog to Reg